from scipy.sparse import spdiags, lil_matrix, vstack, hstack
from numpy import ones, zeros, sin, cos
from numpy import append

class Multilink(object):
    """

    Base class for the N-link model


    Attributes
    ----------
    Nlink : int
        Number of links.
    gamma : float
        Resistance ratio from RFT, gamma >1.
        Also known as anisotropy ratio
    spring_const : float
        Dimensionless spring constant.
    sp : float
        Sperm number.
    """

    def __init__(self, Nlink, gamma, sp):
        super(Multilink, self).__init__()
        self.sp = sp
        self.spring_const =  Nlink/sp**4
        self.gamma = float(gamma)
        self.N = int(Nlink)

    def kinematic_constraint_mat(self, theta):
        """
        Kinematic constraints coefficients.

        x_{i+1} - x_{i} = (1/N)*cos(theta_{i}), differentiate ->
        x_dot_{i+1} - x_dot_{i} +(1/N) sin(theta_{i})theta_dot_{i}=0
        similarly for y

        Parameters
        ----------
        theta : 1d array
            theta for all links.
        Returns
        -------
        Cxx : 2d numpy array N-1 * N
            coefficients for x_dot, x-direction constraint.
        Cxtheta : 2d numpy array N-1 * N
            coefficients for theta_dot
        Cyy : 2d numpy array N-1 * N
            coefficients for y_dot
        Cytheta : 2d numpy array N-1 * N
            coefficients for theta_dot
        NOTE: Cxy Cyx are zeros.
        """

        N = self.N
        Cxx_part1 = lil_matrix(zeros((1, N - 1)))
        Cxx_part1[0, 0] = -1
        Cxx_part2 = lil_matrix(spdiags(ones(N-2), 0, N - 2, N - 1) + spdiags(-ones(N-1), 1, N - 2, N - 1))
        Cxx = vstack((Cxx_part1, Cxx_part2))

        # theta is known (at start of simulation, all theta values are known)
        # theta[0,0] == 0
        Cxtheta = lil_matrix(spdiags(-(1 / N) * sin(theta), 0, N-1, N-1))

        Cyy = Cxx
        Cytheta = lil_matrix(spdiags((1 / N) * cos(theta), 0, N-1, N-1))
        return Cxx, Cxtheta, Cyy, Cytheta

    def viscous_torque_mat(self, x, y, theta):
        """
        Hydrodynamic torque coefficient MATRIX.
        generated by viscous forces experienced by links idx to the end
        evaluated with a moment arm x - xidx

        Parameters
        ----------
        x : 1d array
            x-coordinates of the left ends of link 3 through N
            x-coordinate of the right end of link N
        y : 1d array
            y-coordinates of the left ends of link 3 through N
            y-coordinate of the right end of link N
        theta : 1d array
            theta of link 2 through N


        Returns
        -------
        Tx : 2d numpy array N-1 by N-1
            coefficients for x_dot
        Ty : 2d numpy array N-1 by N-1
            coefficients for y_dot
        Ttheta : 2d numpy array N-1 by N-1
            coefficients for theta_dot
        """
        if len(x) != self.N - 1 or len(y) != self.N - 1 or len(theta) != self.N - 1:
            raise ValueError('x/y/theta should be of length {}'.format(self.N - 1))

        N = self.N
        Tx = lil_matrix((N-1, N-1))
        Ty = lil_matrix((N-1, N-1))
        Ttheta = lil_matrix((N-1, N-1))

        for idx in range(0, N-2):
            link_theta = idx + 1
            link_xy = idx
            xi = x[link_xy]
            yi = y[link_xy]
            coef_x_dot, coef_y_dot, coef_theta_dot = self.viscous_torque_coef(x, y, theta, link_theta, link_xy, xi, yi)
            Tx[idx+1, :-1] = coef_x_dot
            Ty[idx+1, :-1] = coef_y_dot
            Ttheta[idx+1, 1:] = coef_theta_dot

        #Get first row for Tx and Ty (with respect to link 2)
        #Set xi and yi to the second filaments
        link_xy = 0
        link_theta = 1
        xi = self.x2
        yi = self.y2
        coef_x_dot, coef_y_dot, coef_theta_dot = self.viscous_torque_coef(x, y, theta, link_theta, link_xy, xi, yi)
        Tx[0, :-1] = coef_x_dot
        Ty[0, :-1] = coef_y_dot
        Ttheta[0, 1:] = coef_theta_dot
        Ttheta[0,0] = -(1 / 3) * (1 / N ** 3)
        return Tx, Ty, Ttheta

    def viscous_torque_coef(self, x, y, theta, link_theta, link_xy, xi, yi):
        """
        Hydrodynamic torque coefficients.
        generated by viscous forces experienced by links idx to the end
        evaluated with a moment arm x - xidx

        Parameters
        ----------
        x : 1d array
            x-coordinates of the left ends of link 3 through N
            x-coordinate of the right end of link N
        y : 1d array
            y-coordinates of the left ends of link 3 through N
            y-coordinate of the right end of link N
        theta : 1d array
            theta of link 2 through N
        link_num : int
            link number (!STARTING FROM 1).

        Returns
        -------
        coef_x_dot : 1d array
            coefficients for x_dot
        coef_y_dot: 1d array
            coefficients for y_dot
        coef_theta_dot : 1d array
            coefficients for theta_dot
        """

        if len(x) != self.N - 1 or len(y) != self.N - 1 or len(theta) != self.N - 1:
            raise ValueError('x/y/theta should be of length {}'.format(self.N - 1))
        elif link_xy < 0 or link_xy > self.N:
            raise ValueError('0<= link_xy <= {} required, while link_num = {}.'.format(self.N, link_xy))
        elif link_theta < 0 or link_theta > self.N-1:
            raise ValueError('0<= link_theta <= {} required, while link_num = {}.'.format(self.N-1, link_theta))
        elif not isinstance(link_xy, int):
            raise ValueError('link_xy should be an integer.')
        elif not isinstance(link_theta, int):
            raise ValueError('link_theta should be an integer.')

        N, gamma = self.N, self.gamma

        # x_dot coefficients of links link_num to N
        coef_x_dot = (1 / 2) * (1 / N ** 2) * sin(theta[link_theta:]) + \
                     (1 / 2) * (1 / N) * (1 - 1 / gamma) * sin(2 * theta[link_theta:]) * (x[link_xy:-1] - xi) + \
                     (1 / 2) * (1 / N) * (1 + 1 / gamma) * (y[link_xy:-1] - yi) + \
                     -(1 / 2) * (1 / N) * (1 - 1 / gamma) * cos(2 * theta[link_theta:]) * (y[link_xy:-1] - yi)
        # y_dot_coefficients
        coef_y_dot = -(1 / 2) * (1 / N ** 2) * cos(theta[link_theta:]) + \
                     -(1 / 2) * (1 / N) * (1 + 1 / gamma) * (x[link_xy:-1] - xi) + \
                     -(1 / 2) * (1 / N) * (1 - 1 / gamma) * cos(2 * theta[link_theta:]) * (x[link_xy:-1] - xi) + \
                     -(1 / 2) * (1 / N) * (1 - 1 / gamma) * sin(2 * theta[link_theta:]) * (y[link_xy:-1] - yi)
        # theta_dot coefficients
        coef_theta_dot = -(1 / 3) * (1 / N ** 3) \
                         - (1 / 2) * (1 / N ** 2) * cos(theta[link_theta:]) * (x[link_xy:-1] - xi) \
                         - (1 / 2) * (1 / N ** 2) * sin(theta[link_theta:]) * (y[link_xy:-1] - yi)
        # fill in zeros for links 1 to link_num -1.
        fill_zeros = lambda vector: append(zeros(link_xy), vector)
        coef_x_dot = fill_zeros(coef_x_dot)
        coef_y_dot = fill_zeros(coef_y_dot)
        coef_theta_dot = fill_zeros(coef_theta_dot)
        return coef_x_dot, coef_y_dot, coef_theta_dot

    def viscous_force_x_coef(self, theta):
        """
        Hydrodynamic forces experienced by all links in x-direction.

        Parameters
        ----------
        theta : 1d array
            theta for all links.
        Returns
        -------
        coef_x_dot : 1d array
            coefficients for x_dot
        coef_y_dot: 1d array
            coefficients for y_dot
        coef_theta_dot : 1d array
            coefficients for theta_dot
        """
        m,n = theta.shape

        if n != self.N-1:
            raise ValueError('theta should have {} columns'.format(self.N))
        N, gamma = self.N ,self.gamma
        coef_x_dot = -(1/N)*(1/gamma)*cos(theta)**2-(1/N)*sin(theta)**2
        coef_y_dot = (1/2)*(1/N)*(1-1/gamma)*sin(2*theta)
        coef_theta_dot = (1/2)*(1/N**2)*sin(theta)
        return coef_x_dot, coef_y_dot, coef_theta_dot